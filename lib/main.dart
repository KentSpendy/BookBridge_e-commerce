import 'package:bookbridgev1/auth/reset_password_screen.dart';
import 'package:bookbridgev1/auth/signup_screen.dart';
import 'package:bookbridgev1/auth/login_screen.dart';
import 'package:bookbridgev1/screens/home_screen.dart';
import 'package:bookbridgev1/auth/auth%20service/auth_service.dart';
import 'package:bookbridgev1/repositories/book_repository.dart';
import 'package:bookbridgev1/screens/messaging_screen.dart';
import 'package:bookbridgev1/screens/my_sales_screen.dart';
import 'package:bookbridgev1/service/chat_service.dart';
import 'package:bookbridgev1/service/notification_service.dart';
import 'package:bookbridgev1/provider/favorite_provider.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:provider/provider.dart';
import './repositories/transaction_repository.dart';
import 'package:bookbridgev1/repositories/notification_repository.dart';
import './service/in_app_notification_service.dart';
import 'package:bookbridgev1/models/notification_model.dart';
import 'firebase_options.dart'; // Generated by FlutterFire CLI
import 'dart:io' show Platform;
import 'package:flutter/foundation.dart' show kIsWeb;

// FCM background handler
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  await NotificationService.showNotification(message);
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  try {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    debugPrint('Firebase initialized successfully');

    await _initializeFirebaseMessaging();
    await NotificationService.init();
  } catch (e, stack) {
    debugPrint('Firebase initialization error: $e\n$stack');
  }

  await SystemChrome.setPreferredOrientations([
    DeviceOrientation.portraitUp,
    DeviceOrientation.portraitDown,
  ]);

  SystemChrome.setSystemUIOverlayStyle(
    const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: Brightness.dark,
      systemNavigationBarColor: Colors.white,
      systemNavigationBarIconBrightness: Brightness.dark,
    ),
  );

  runApp(
    MultiProvider(
      providers: [
        Provider<TransactionRepository>(create: (_) => TransactionRepository()),
        Provider<NotificationRepository>(create: (_) => NotificationRepository()),
        ChangeNotifierProvider(create: (_) => AuthService()),
        ChangeNotifierProvider(create: (_) => BookRepository()),
        ChangeNotifierProvider(create: (_) => ChatService()),
        ChangeNotifierProvider(create: (_) => FavoritesProvider()),
      ],
      child: const BookBridgeApp(),
    ),
  );
}

Future<void> _initializeFirebaseMessaging() async {
  try {
    await FirebaseMessaging.instance.setAutoInitEnabled(true);

    final settings = await FirebaseMessaging.instance.requestPermission(
      alert: true,
      badge: true,
      sound: true,
      provisional: true,
    );

    debugPrint('Notification permissions: ${settings.authorizationStatus}');
    final token = await FirebaseMessaging.instance.getToken();
    debugPrint('FCM Token: $token');

    FirebaseMessaging.instance.onTokenRefresh.listen((newToken) {
      debugPrint('FCM Token refreshed: $newToken');
    });

    FirebaseMessaging.onMessage.listen((RemoteMessage message) {
      debugPrint('Received foreground message: ${message.messageId}');
      NotificationService.showNotification(message);
    });

    // Register background handler ONLY on mobile
    if (!kIsWeb && (Platform.isAndroid || Platform.isIOS)) {
      FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
    }

    FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
      debugPrint('Notification opened: ${message.messageId}');
    });

    final initialMessage = await FirebaseMessaging.instance.getInitialMessage();
    if (initialMessage != null) {
      debugPrint('App opened from terminated state via notification');
    }
  } catch (e, stack) {
    debugPrint('FCM initialization error: $e\n$stack');
  }
}

class BookBridgeApp extends StatelessWidget {
  const BookBridgeApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'BookBridge',
      debugShowCheckedModeBanner: false,
      theme: _buildAppTheme(),
      home: const AppEntryPoint(),
      routes: _buildAppRoutes(),
      onGenerateRoute: (settings) {
        if (settings.name == '/message') {
          final data = settings.arguments as Map<String, dynamic>;
          return MaterialPageRoute(
            builder: (context) => MessagingScreen(
              otherUserId: data['senderId'],
              currentUserId: data['currentUserId'],
              chatService: context.read<ChatService>(),
            ),
          );
        }
        return null;
      },
    );
  }

  ThemeData _buildAppTheme() {
    return ThemeData(
      colorScheme: ColorScheme.fromSeed(
        seedColor: Colors.green,
        brightness: Brightness.light,
      ),
      useMaterial3: true,
      appBarTheme: const AppBarTheme(
        elevation: 0,
        centerTitle: true,
        scrolledUnderElevation: 1,
      ),
      textTheme: const TextTheme(
        bodyLarge: TextStyle(fontSize: 16),
        bodyMedium: TextStyle(fontSize: 14),
      ),
    );
  }

  Map<String, WidgetBuilder> _buildAppRoutes() {
    return {
      '/login': (context) => const LoginScreen(),
      '/signup': (context) => const SignupScreen(),
      '/reset-password': (context) => const ResetPasswordScreen(),
      '/home': (context) => const HomeScreen(),
      '/my-sales': (context) => const MySalesScreen(),
    };
  }
}

class AppEntryPoint extends StatelessWidget {
  const AppEntryPoint({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer<AuthService>(
      builder: (context, authService, _) {
        if (authService.isLoading) {
          return const Scaffold(
            body: Center(child: CircularProgressIndicator()),
          );
        }

        final currentUser = authService.currentUser;
        //Scaffhold oh wow 
        return Scaffold(
          body: Builder(
            builder: (context) {
              return StreamBuilder<NotificationModel>(
                stream: currentUser != null
                    ? InAppNotificationService().notificationStream(currentUser.uid)
                    : const Stream.empty(),
                builder: (context, snapshot) {
                  if (snapshot.hasData) { 
                    final notification = snapshot.data!;
                    WidgetsBinding.instance.addPostFrameCallback((_) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text('${notification.title}: ${notification.body}'),
                          duration: const Duration(seconds: 4),
                          behavior: SnackBarBehavior.floating,
                        ),
                      );
                    });
                  }

                  return currentUser == null
                      ? const LoginScreen()
                      : const HomeScreen();
                },
              );
            },
          ),
        );
      },
    );
  }
}